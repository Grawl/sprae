{
  "version": 3,
  "sources": ["node_modules/@preact/signals-core/src/index.ts", "src/state.signals-proxy.js", "src/domdiff.js", "src/util.js", "src/directives.js", "src/core.js", "src/index.js"],
  "sourcesContent": ["function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\nfunction mutationDetected(): never {\n\tthrow new Error(\"Computed cannot have side-effects\");\n}\n\nconst identifier = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\nlet untrackedDepth = 0;\n\nfunction untracked<T>(callback: () => T): T {\n\tif (untrackedDepth > 0) {\n\t\treturn callback();\n\t}\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\tuntrackedDepth++;\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tuntrackedDepth--;\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         \u2191     \u2191\n\t\t *        tail  node (new)\n\t\t *               \u2193\n\t\t * { A <-> B <-> C }\n\t\t *               \u2191\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         \u2191           \u2191\n\t\t *        node   \u250C\u2500\u2500\u2500 tail (evalContext._sources)\n\t\t *         \u2514\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2510\n\t\t *               \u2193     \u2193\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     \u2191\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof identifier;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = identifier\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (evalContext instanceof Computed) {\n\t\t\tmutationDetected();\n\t\t}\n\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   \u2191           \u2191\n\t *                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\t * target._sources = A; (node is head)  \u2502\n\t *                   \u2193                  \u2502\n\t * target._sources = C; (node is tail) \u2500\u2518\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         \u2193\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   \u2191     \u2191     \u2191\n\t\t\t *   \u2502     \u2502     \u2514 head = node\n\t\t\t *   \u2502     \u2514 head = node\n\t\t\t *   \u2514 head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._compute = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectCleanup = () => unknown;\ndeclare class Effect {\n\t_compute?: () => unknown | EffectCleanup;\n\t_cleanup?: () => unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => unknown | EffectCleanup);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._compute === undefined) return;\n\n\t\tconst cleanup = this._compute();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup as EffectCleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n\tconst effect = new Effect(compute);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport {\n\tsignal,\n\tcomputed,\n\teffect,\n\tbatch,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n", "// signals-based proxy\n// + we need proxy for sandbox & arrays anyways\n// + it seems faster than defining a bunch of props on sealed state object\n// + we need support signal inputs\n// + signals provide nice tracking mechanism, unlike own arrays\n// + signals detect cycles\n// + it's just robust\n// ? must it modify initial store\n\nimport { signal, computed, effect, batch } from '@preact/signals-core'\n// import { signal, computed } from 'usignal/sync'\n// import { signal, computed } from '@webreflection/signal'\n\nexport { effect as fx, batch }\n\n// default root sandbox\nexport const sandbox = {\n  Array, Object, Number, String, Boolean, Date,\n  console, window, document, history, navigator, location, screen, localStorage, sessionStorage,\n  alert, prompt, confirm, fetch, performance,\n  setTimeout, setInterval, requestAnimationFrame\n}\n\nconst isObject = v => v?.constructor === Object\nconst memo = new WeakMap\n\n// track last accessed property to figure out if .length was directly accessed from expression or via .push/etc method\nlet lastProp\n\nexport default function createState(values, parent) {\n  if (!isObject(values) && !Array.isArray(values)) return values;\n  if (memo.has(values) && !parent) return values;\n  // console.group('createState', values, parent)\n  // .length signal is stored outside, since cannot be replaced\n  const _len = Array.isArray(values) && signal(values.length),\n    // dict with signals storing values\n    signals = parent ? Object.create(memo.get(parent = createState(parent))) : Array.isArray(values) ? [] : {},\n    // proxy conducts prop access to signals\n    state = new Proxy(signals, {\n      // sandbox everything\n      has() { return true },\n      get(signals, key) {\n        // console.log('get', key, signals)\n        if (typeof key === 'symbol') return values[key]\n        // if .length is read within .push/etc - peek signal (don't subscribe)\n        if (_len)\n          if (key === 'length') return Array.prototype[lastProp] ? _len.peek() : _len.value;\n          else lastProp = key;\n        return (signals[key] || initSignal(key))?.valueOf()\n      },\n      set(signals, key, v) {\n        if (typeof key === 'symbol') values[key] = v\n\n        // .length\n        else if (_len && key === 'length') _len.value = signals.length = v;\n\n        else {\n          const s = signals[key] || initSignal(key)\n\n          // new unknown property\n          if (!s) signals[key] = signal(createState(v?.valueOf()))\n          // stashed _set for values with getter/setter\n          else if (s._set) s._set(v)\n          // FIXME: is there meaningful way to update same-signature object?\n          // else if (isObject(v) && isObject(s.value)) Object.assign(s.value, v)\n          // .x = y\n          else s.value = createState(v?.valueOf())\n        }\n\n        return true\n      }\n    })\n\n  // init signals placeholders (instead of ownKeys & getOwnPropertyDescriptor handlers)\n  // if values are existing proxy - take its signals instead of creating new ones\n  let initSignals = memo.get(values)\n  for (let key in values) values[key], signals[key] = initSignals?.[key];\n\n  // initialize signal for provided key\n  // FIXME: chances are there's redundant checks\n  function initSignal(key) {\n    // init existing value\n    if (values.hasOwnProperty(key)) {\n      // create signal from descriptor\n      const desc = Object.getOwnPropertyDescriptor(values, key)\n      // getter turns into computed\n      if (desc?.get) {\n        // stash setter\n        (signals[key] = computed(desc.get.bind(state)))._set = desc.set?.bind(state);\n        return signals[key]\n      }\n      return signals[key] = desc.value?.peek ? desc.value : signal(createState(desc.value))\n    }\n\n    // touch parent\n    if (parent) return parent[key]\n\n    // Array, window etc\n    if (sandbox.hasOwnProperty(key)) return sandbox[key]\n  }\n\n  memo.set(state, signals)\n  // console.groupEnd()\n  return state\n}\n", "// https://github.com/luwes/js-diff-benchmark/blob/master/libs/list-difference.js\n// this implementation is more persistent in terms of preserving in-between nodes\n// also it handles _dispose\n\n// a is old list, b is the new\nexport default function (parent, a, b, before) {\n  const aIdx = new Map();\n  const bIdx = new Map();\n  let i;\n  let j;\n\n  // Create a mapping from keys to their position in the new list\n  for (i = 0; i < b.length; i++) {\n    bIdx.set(b[i], i);\n  }\n\n  // Create a mapping from keys to their position in the old list\n  for (i = 0; i < a.length; i++) {\n    aIdx.set(a[i], i);\n    // dispose a[i] if is going to disappear\n    if (!bIdx.has(a[i])) a[i][Symbol.dispose]?.()\n  }\n\n  for (i = j = 0; i !== a.length || j !== b.length;) {\n    var aElm = a[i], bElm = b[j];\n    if (aElm === null) {\n      // This is a element that has been moved to earlier in the list\n      i++;\n    } else if (b.length <= j) {\n      // No more elements in new, this is a delete\n      parent.removeChild(a[i]);\n      i++;\n    } else if (a.length <= i) {\n      // No more elements in old, this is an addition\n      parent.insertBefore(bElm, a[i] || before);\n      j++;\n    } else if (aElm === bElm) {\n      // No difference, we move on\n      i++; j++;\n    } else {\n      // Look for the current element at this location in the new list\n      // This gives us the idx of where this element should be\n      var curElmInNew = bIdx.get(aElm);\n      // Look for the the wanted elment at this location in the old list\n      // This gives us the idx of where the wanted element is now\n      var wantedElmInOld = aIdx.get(bElm);\n      if (curElmInNew === undefined) {\n        // Current element is not in new list, it has been removed\n        parent.removeChild(a[i]);\n        i++;\n      } else if (wantedElmInOld === undefined) {\n        // New element is not in old list, it has been added\n        parent.insertBefore(\n          bElm,\n          a[i] || before\n        );\n        j++;\n      } else {\n        // Element is in both lists, it has been moved\n        parent.insertBefore(\n          a[wantedElmInOld],\n          a[i] || before\n        );\n        a[wantedElmInOld] = null;\n        if (wantedElmInOld > i + 1) i++;\n        j++;\n      }\n    }\n  }\n  return b;\n};\n", "\n// reset stacktrace or plan for fastest next call\n// https://twitter.com/_developit/status/1634033380940455936\nexport const queueMicrotask = Promise.prototype.then.bind(Promise.resolve());\n\n// based on https://github.com/WebReflection/not-so-weak/\nconst refs = new WeakMap;\n\nconst set = value => {\n  const ref = new WeakRef(value);\n  refs.set(value, ref);\n  return ref;\n};\n\nconst get = value => refs.get(value) || set(value);\n\nexport class WeakishMap extends Map {\n  #registry = new FinalizationRegistry(key => super.delete(key));\n  get size() { return [...this].length }\n  constructor(entries = []) {\n    super();\n    for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(key)?.deref();\n  }\n  set(key, value) {\n    let ref = super.get(key);\n    if (ref) this.#registry.unregister(ref);\n    ref = get(value);\n    this.#registry.register(value, key, ref);\n    return super.set(key, ref);\n  }\n}", "// directives & parsing\nimport sprae from './core.js'\nimport swap from './domdiff.js'\n// import swap from 'swapdom'\nimport createState from './state.signals-proxy.js'\nimport { queueMicrotask, WeakishMap } from './util.js'\n\n\n// reserved directives - order matters!\n// primary initialized first by selector, secondary initialized by iterating attributes\nexport const primary = {}, secondary = {}\n\n// :if is interchangeable with :each depending on order, :if :each or :each :if have different meanings\n// as for :if :with - :if must init first, since it is lazy, to avoid initializing component ahead of time by :with\n// we consider :with={x} :if={x} case insignificant\nprimary['if'] = (el, expr) => {\n  let holder = document.createTextNode(''),\n    clauses = [parseExpr(el, expr, ':if')],\n    els = [el], cur = el\n\n  while (cur = el.nextElementSibling) {\n    if (cur.hasAttribute(':else')) {\n      cur.removeAttribute(':else');\n      if (expr = cur.getAttribute(':if')) {\n        cur.removeAttribute(':if'), cur.remove();\n        els.push(cur); clauses.push(parseExpr(el, expr, ':else :if'));\n      }\n      else {\n        cur.remove(); els.push(cur); clauses.push(() => 1);\n      }\n    }\n    else break;\n  }\n\n  el.replaceWith(cur = holder)\n\n  return (state) => {\n    let i = clauses.findIndex(f => f(state))\n    if (els[i] != cur) {\n      ; (cur[_each] || cur).replaceWith(cur = els[i] || holder);\n      // NOTE: it lazily initializes elements on insertion, it's safe to sprae multiple times\n      // but :if must come first to avoid preliminary caching\n      sprae(cur, state);\n    }\n  }\n}\n\nconst _each = Symbol(':each')\n\n// configure domswap so that when elements are removed by :each, their listeners are removed either\n// swap.replace = (a, b, parent) => (a[_dispose]?.(), parent.replaceChild(b, a))\n// swap.remove = (a, parent) => (a[_dispose]?.(), parent.removeChild(a))\n\n// :each must init before :ref, :id or any others, since it defines scope\nprimary['each'] = (tpl, expr) => {\n  let each = parseForExpression(expr);\n  if (!each) return exprError(new Error, tpl, expr, ':each');\n\n  // FIXME: make sure no memory leak here\n  // we need :if to be able to replace holder instead of tpl for :if :each case\n  const holder = tpl[_each] = document.createTextNode('')\n  tpl.replaceWith(holder)\n\n  const evaluate = parseExpr(tpl, each[2], ':each');\n\n  const keyExpr = tpl.getAttribute(':key');\n  const itemKey = keyExpr ? parseExpr(null, keyExpr, ':each') : null;\n  tpl.removeAttribute(':key')\n\n  const refExpr = tpl.getAttribute(':ref');\n\n  const scopes = new WeakishMap() // stores scope per data item\n  const itemEls = new WeakishMap() // element per data item\n  let curEls = []\n\n  return (state) => {\n    // get items\n    let list = evaluate(state)\n\n    if (!list) list = []\n    else if (typeof list === 'number') list = Array.from({ length: list }, (_, i) => [i + 1, i])\n    else if (Array.isArray(list)) list = list.map((item, i) => [i + 1, item])\n    else if (typeof list === 'object') list = Object.entries(list)\n    else exprError(Error('Bad list value'), tpl, expr, ':each', list)\n\n    // collect elements/scopes for items\n    let newEls = [], elScopes = []\n\n    for (let [idx, item] of list) {\n      let el, scope, key = itemKey?.({ [each[0]]: item, [each[1]]: idx })\n\n      // we consider if data items are primitive, then nodes needn't be cached\n      // since likely they're very simple to create\n      if (key == null) el = tpl.cloneNode(true);\n      else (el = itemEls.get(key)) || itemEls.set(key, el = tpl.cloneNode(true));\n\n      newEls.push(el)\n\n      if (key == null || !(scope = scopes.get(key))) {\n        scope = createState({ [each[0]]: item, [refExpr || '']: null, [each[1]]: idx }, state)\n        if (key != null) scopes.set(key, scope)\n      }\n      // need to explicitly set item to update existing children's values\n      else scope[each[0]] = item\n\n      elScopes.push(scope)\n    }\n\n    swap(holder.parentNode, curEls, newEls, holder)\n    curEls = newEls\n\n    // init new elements\n    for (let i = 0; i < newEls.length; i++) {\n      newEls[i][Symbol.dispose] = sprae(newEls[i], elScopes[i])[Symbol.dispose]\n    }\n  }\n}\n\n// `:each` can redefine scope as `:each=\"a in {myScope}\"`,\n// same time per-item scope as `:each=\"...\" :with=\"{collapsed:true}\"` is useful\nprimary['with'] = (el, expr, rootState) => {\n  let evaluate = parseExpr(el, expr, ':with')\n  const localState = evaluate(rootState)\n  let state = createState(localState, rootState)\n  sprae(el, state);\n}\n\n// ref must be last within primaries, since that must be skipped by :each, but before secondaries\nprimary['ref'] = (el, expr, state) => {\n  // FIXME: wait for complex ref use-case\n  // parseExpr(el, `__scope[${expr}]=this`, ':ref')(values)\n  state[expr] = el;\n}\n\n\n// This was taken AlpineJS, former VueJS 2.* core. Thanks Alpine & Vue!\n// takes instruction like `item in list`, returns ['item', '', 'list']\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n  let inMatch = expression.match(forAliasRE)\n\n  if (!inMatch) return\n\n  let items = inMatch[2].trim()\n  let item = inMatch[1].replace(stripParensRE, '').trim()\n  let iteratorMatch = item.match(forIteratorRE)\n\n  if (iteratorMatch) return [\n    item.replace(forIteratorRE, '').trim(),\n    iteratorMatch[1].trim(),\n    items\n  ]\n\n  // FIXME: it can possibly return index as second param\n  return [item, '', items]\n}\n\nsecondary['render'] = (el, expr, state) => {\n  let evaluate = parseExpr(el, expr, ':render'),\n    tpl = evaluate(state)\n\n  if (!tpl) exprError(new Error('Template not found'), el, expr, ':render');\n\n  let content = tpl.content.cloneNode(true);\n  el.replaceChildren(content)\n  sprae(el, state)\n}\n\nsecondary['id'] = (el, expr) => {\n  let evaluate = parseExpr(el, expr, ':id')\n  const update = v => el.id = v || v === 0 ? v : ''\n  return (state) => { update(evaluate(state)) }\n}\n\nsecondary['class'] = (el, expr) => {\n  let evaluate = parseExpr(el, expr, ':class')\n  let initClassName = el.getAttribute('class')\n  return (state) => {\n    let v = evaluate(state)\n    let className = [initClassName]\n    if (v) {\n      if (typeof v === 'string') className.push(v)\n      else if (Array.isArray(v)) className.push(...v)\n      else className.push(...Object.entries(v).map(([k, v]) => v ? k : ''))\n    }\n    if (className = className.filter(Boolean).join(' ')) el.setAttribute('class', className);\n    else el.removeAttribute('class')\n  }\n}\n\nsecondary['style'] = (el, expr) => {\n  let evaluate = parseExpr(el, expr, ':style')\n  let initStyle = el.getAttribute('style') || ''\n  if (!initStyle.endsWith(';')) initStyle += '; '\n  return (state) => {\n    let v = evaluate(state)\n    if (typeof v === 'string') el.setAttribute('style', initStyle + v)\n    else {\n      el.setAttribute('style', initStyle)\n      for (let k in v) el.style.setProperty(k, v[k])\n    }\n  }\n}\n\nsecondary['text'] = (el, expr) => {\n  let evaluate = parseExpr(el, expr, ':text')\n  return (state) => {\n    let value = evaluate(state)\n    el.textContent = value == null ? '' : value;\n  }\n}\n\n// set props in-bulk or run effect\nsecondary[''] = (el, expr) => {\n  let evaluate = parseExpr(el, expr, ':')\n  if (evaluate) return (state) => {\n    let value = evaluate(state)\n    for (let key in value) attr(el, dashcase(key), value[key]);\n  }\n}\n\n// connect expr to element value\nsecondary['value'] = (el, expr) => {\n  let evaluate = parseExpr(el, expr, ':value')\n\n  let from, to\n  let update = (\n    el.type === 'text' || el.type === '' ? value => el.setAttribute('value', el.value = value == null ? '' : value) :\n      el.tagName === 'TEXTAREA' || el.type === 'text' || el.type === '' ? value => (\n        // we retain selection in input\n        from = el.selectionStart, to = el.selectionEnd,\n        el.setAttribute('value', el.value = value == null ? '' : value),\n        from && el.setSelectionRange(from, to)\n      ) :\n        el.type === 'checkbox' ? value => (el.value = value ? 'on' : '', attr(el, 'checked', value)) :\n          el.type === 'select-one' ? value => {\n            for (let option in el.options) option.removeAttribute('selected')\n            el.value = value;\n            el.selectedOptions[0]?.setAttribute('selected', '')\n          } :\n            value => el.value = value\n  )\n\n  return (state) => { update(evaluate(state)) }\n}\n\n// any unknown directive\nexport default (el, expr, state, name) => {\n  let evt = name.startsWith('on') && name.slice(2)\n  let evaluate = parseExpr(el, expr, ':' + name)\n\n  if (!evaluate) return\n\n  if (evt) return (state => {\n    // we need anonymous callback to enable modifiers like prevent\n    let value = evaluate(state) || (() => { })\n    return on(el, evt, value)\n  })\n\n  return state => { attr(el, name, evaluate(state)) }\n}\n\n// bind event to a target\nexport const on = (el, e, fn) => {\n  if (!fn) return\n\n  const ctx = { evt: '', target: el, test: () => true };\n\n  // onevt.debounce-108 -> evt.debounce-108\n  ctx.evt = (e.startsWith('on') ? e.slice(2) : e).replace(/\\.(\\w+)?-?([-\\w]+)?/g,\n    (match, mod, param = '') => (ctx.test = mods[mod]?.(ctx, ...param.split('-')) || ctx.test, '')\n  );\n\n  // add listener applying the context\n  const { evt, target, test, defer, stop, prevent, ...opts } = ctx;\n\n  if (defer) fn = defer(fn)\n\n  const cb = e => test(e) && (\n    stop && e.stopPropagation(),\n    prevent && e.preventDefault(),\n    fn.call(target, e)\n  )\n\n  target.addEventListener(evt, cb, opts)\n\n  // return off\n  return () => (target.removeEventListener(evt, cb, opts))\n}\n\n// event modifiers\nconst mods = {\n  // actions\n  prevent(ctx) { ctx.prevent = true },\n  stop(ctx) { ctx.stop = true },\n\n  // options\n  once(ctx) { ctx.once = true; },\n  passive(ctx) { ctx.passive = true; },\n  capture(ctx) { ctx.capture = true; },\n\n  // target\n  window(ctx) { ctx.target = window },\n  document(ctx) { ctx.target = document },\n\n  throttle(ctx, limit) { ctx.defer = fn => throttle(fn, limit ? Number(limit) || 0 : 108) },\n  debounce(ctx, wait) { ctx.defer = fn => debounce(fn, wait ? Number(wait) || 0 : 108) },\n\n  // test\n  outside: ctx => e => {\n    let target = ctx.target\n    if (target.contains(e.target)) return false\n    if (e.target.isConnected === false) return false\n    if (target.offsetWidth < 1 && target.offsetHeight < 1) return false\n    return true\n  },\n  self: ctx => e => e.target === ctx.target,\n\n  // keyboard\n  ctrl: (ctx, ...param) => e => keys.ctrl(e) && param.every(p => keys[p] ? keys[p](e) : e.key === p),\n  shift: (ctx, ...param) => e => keys.shift(e) && param.every(p => keys[p] ? keys[p](e) : e.key === p),\n  alt: (ctx, ...param) => e => keys.alt(e) && param.every(p => keys[p] ? keys[p](e) : e.key === p),\n  meta: (ctx, ...param) => e => keys.meta(e) && param.every(p => keys[p] ? keys[p](e) : e.key === p),\n  arrow: ctx => keys.arrow,\n  enter: ctx => keys.enter,\n  escape: ctx => keys.escape,\n  tab: ctx => keys.tab,\n  space: ctx => keys.space,\n  backspace: ctx => keys.backspace,\n  delete: ctx => keys.delete,\n  digit: ctx => keys.digit,\n  letter: ctx => keys.letter,\n  character: ctx => keys.character,\n};\n\n// key testers\nconst keys = {\n  ctrl: e => e.ctrlKey || e.key === 'Control' || e.key === 'Ctrl',\n  shift: e => e.shiftKey || e.key === 'Shift',\n  alt: e => e.altKey || e.key === 'Alt',\n  meta: e => e.metaKey || e.key === 'Meta' || e.key === 'Command',\n  arrow: e => e.key.startsWith('Arrow'),\n  enter: e => e.key === 'Enter',\n  escape: e => e.key.startsWith('Esc'),\n  tab: e => e.key === 'Tab',\n  space: e => e.key === '\u00A0' || e.key === 'Space' || e.key === ' ',\n  backspace: e => e.key === 'Backspace',\n  delete: e => e.key === 'Delete',\n  digit: e => /^\\d$/.test(e.key),\n  letter: e => /^[a-zA-Z]$/.test(e.key),\n  character: e => /^\\S$/.test(e.key)\n}\n\n// create delayed fns\nconst throttle = (fn, limit) => {\n  let pause, planned, block = (e) => {\n    pause = true\n    setTimeout(() => {\n      pause = false\n      // if event happened during blocked time, it schedules call by the end\n      if (planned) return (planned = false, block(e), fn(e))\n    }, limit)\n  }\n  return (e) => {\n    if (pause) return (planned = true)\n    block(e);\n    return fn(e);\n  }\n}\nconst debounce = (fn, wait) => {\n  let timeout\n  return (e) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => { timeout = null; fn(e) }, wait)\n  }\n}\n\n// set attr\nconst attr = (el, name, v) => {\n  if (v == null || v === false) el.removeAttribute(name)\n  else el.setAttribute(name, v === true ? '' : (typeof v === 'number' || typeof v === 'string') ? v : '')\n}\n\n\n// borrowed from alpine with improvements https://github.com/alpinejs/alpine/blob/main/packages/alpinejs/src/evaluator.js#L61\n// it seems to be more robust than subscript\nlet evaluatorMemo = {}\nfunction parseExpr(el, expression, dir) {\n  // guard static-time eval errors\n  let evaluate = evaluatorMemo[expression]\n\n  if (!evaluate) {\n    try {\n      evaluate = evaluatorMemo[expression] = new Function(`__scope`, `with (__scope) { return ${expression.trim()} };`)\n    } catch (e) {\n      return exprError(e, el, expression, dir)\n    }\n  }\n\n  // guard runtime eval errors\n  return (state) => {\n    let result\n    try { result = evaluate.call(el, state); }\n    catch (e) { return exprError(e, el, expression, dir) }\n    return result\n  }\n}\n\nfunction exprError(error, element, expression, directive) {\n  Object.assign(error, { element, expression })\n  console.warn(`\u2234 ${error.message}\\n\\n${directive}=${expression ? `\"${expression}\"\\n\\n` : ''}`, element)\n  queueMicrotask(() => { throw error }, 0)\n}\n\nfunction dashcase(str) {\n  return str.replace(/[A-Z\\u00C0-\\u00D6\\u00D8-\\u00DE]/g, (match) => '-' + match.toLowerCase());\n};\n", "import createState, { fx, batch, sandbox } from './state.signals-proxy.js';\nimport defaultDirective, { primary, secondary, on } from './directives.js';\n\n// provide dispose symbol\nSymbol.dispose ||= Symbol('dispose');\n\n// default root sandbox\nsprae.globals = sandbox\n\n// sprae element: apply directives\nconst memo = new WeakMap\nexport default function sprae(container, values) {\n  if (!container.children) return\n  if (memo.has(container)) return batch(() => Object.assign(memo.get(container), values))\n\n  const state = createState(values || {});\n  const updates = [], disposes = []\n\n  // init directives on element\n  const init = (el, parent = el.parentNode) => {\n    // init primary attributes first\n    for (let name in primary) {\n      let attrName = ':' + name\n      if (el.hasAttribute?.(attrName)) {\n        let expr = el.getAttribute(attrName)\n        el.removeAttribute(attrName)\n\n        updates.push(primary[name](el, expr, state, name))\n\n        // stop if element was spraed by directive or skipped (detached)\n        if (memo.has(el)) return\n        if (el.parentNode !== parent) return false\n      }\n    }\n\n    // catch other attributes as secondary\n    if (el.attributes) {\n      for (let i = 0; i < el.attributes.length;) {\n        let attr = el.attributes[i], prefix = attr.name[0]\n\n        if (prefix === ':' || prefix === '@') {\n          el.removeAttribute(attr.name)\n          let expr = prefix === '@' ? `${attr.value.includes('await') ? 'async' : ''} event=>{${attr.value}}` : attr.value,\n            names = attr.name.slice(1).split(prefix)\n\n          // multiple attributes like :id:for=\"\" or @click@touchstart\n          for (let name of names) {\n            // @click forwards to :onclick=event=>{...inline}\n            if (prefix === '@') name = `on` + name\n            let dir = secondary[name] || defaultDirective;\n            updates.push(dir(el, expr, state, name));\n            // NOTE: secondary directives don't stop flow nor extend state, so no need to check\n          }\n        }\n        else i++;\n      }\n    }\n\n    for (let i = 0, child; child = el.children[i]; i++) {\n      // if element was removed from parent (skipped) - reduce index\n      if (init(child, el) === false) i--\n    }\n  }\n\n  init(container);\n\n  // call updates: subscribes directives to state;\n  // saves disposal functions\n  // FIXME: make sure internal states are disposed as well\n  for (let update of updates) if (update) {\n    // save teardown under specifix index\n    const idx = disposes.length\n    disposes.push(null, fx(() => {\n      disposes[idx]?.();\n      disposes[idx] = update(state);\n    }));\n  }\n\n  memo.set(container, state);\n\n  // export disposer\n  state[Symbol.dispose] = () => {\n    while (disposes.length) disposes.shift()?.();\n    memo.delete(container);\n  };\n\n  return state;\n}\n", "import sprae from './core.js';\nimport './directives.js';\nexport default sprae;\n\n// autoinit\nif (document.currentScript) sprae(document.documentElement)\n"],
  "mappings": "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",
  "names": ["cycleDetected", "Error", "identifier", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "batch", "callback", "evalContext", "batchedEffect", "batchDepth", "batchIteration", "globalVersion", "addDependency", "signal", "evalContext", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_flags", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "identifier", "_refresh", "_unsubscribe", "prev", "next", "subscribe", "fn", "effect", "flag", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Computed", "Error", "mutationDetected", "cycleDetected", "_notify", "endBatch", "needsToRecompute", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "compute", "call", "undefined", "_compute", "_globalVersion", "prevContext", "err", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "_nextBatchedEffect", "_callback", "finish", "_start", "bind", "_dispose", "v", "signals", "a", "b", "i", "i", "f", "_", "v", "state", "e", "p", "memo", "i", "attr"]
}
